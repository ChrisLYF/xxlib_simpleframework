#include "xx_bbuffer.h"
#include "xx_dict.h"
#include "xx_luahelper.h"
#include <iostream>

typedef xx::MemPool<> MP;


int main()
{
	MP mp;
	xx::String_v s(mp);
	xx::BBuffer_v bb(mp);
	xx::Dict_v<void*, uint32_t> pd(mp);
	xx::Dict_v<uint32_t, std::pair<int, xx::LuaTypes>> od(mp);

	auto L = xx::Lua_NewState(mp);
	auto rtv = luaL_dostring(L, R"##(
t = {}
t[1] = "asdfqwer"
t.i = 123
t.s = t[1]
t.t = { t, 1, 2, t[1] }
t.t.s = t.s
t.t[t] = t
)##");
	assert(!rtv);

	// 将要序列化的值放到 L 顶, 序列化后移除
	lua_getglobal(L, "t");
	auto r = xx::Lua_ToBBuffer(*pd, *bb, L, lua_gettop(L));
	assert(!r);
	lua_pop(L, 1);

	// 打印序列化数据
	bb->ToString(*s);
	std::cout << s->C_str() << std::endl;

	// 反序列化, 压入 L 顶, 放到 global t2
	r = xx::Lua_PushFromBBuffer(*od, *bb, L);
	assert(!r);
	lua_setglobal(L, "t2");
	
	// 在 lua 中校验输出
	rtv = luaL_dostring(L, R"##(
print( t2 )
print( t2[1] )
print( t2.i )
print( t2.s )
print( t2.t )
print( t2.t[1] )
print( t2.t[2] )
print( t2.t[3] )
print( t2.t[4] )
print( t2.t.s )
print( t2.t[t2] )
)##");
	assert(!rtv);
	lua_close(L);
	return 0;
}
