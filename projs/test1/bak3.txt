#include "lua.hpp"
#include "xx_mempool.h"
#include "xx_dict.h"
#include <iostream>
#include <string>
#include <unordered_map>

int main()
{

	auto code = R"~~(
local t = {}
t.xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = 1
t.yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy = 2
t.zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz = 3
)~~";
	// 传统工艺
	auto L1 = luaL_newstate();
	luaL_openlibs(L1);
	luaL_dostring(L1, code);
	assert(!rtv);

	// 内存池加持
	xx::MemPoolBase mpb;
	auto L2 = lua_newstate([](void *ud, void *ptr, size_t osize, size_t nsize)
	{
		return ((xx::MemPoolBase*)ud)->Realloc(ptr, nsize, osize);
	}, &mpb);
	luaL_openlibs(L2);

	xx::Stopwatch sw;
	for (int i = 0; i < 99999; ++i)
	{
		luaL_dostring(L1, code);
	}
	std::cout << "L1 elapsed = " << sw() << std::endl;
	for (int i = 0; i < 99999; ++i)
	{
		luaL_dostring(L2, code);
	}
	std::cout << "L2 elapsed = " << sw() << std::endl;
	for (int i = 0; i < 99999; ++i)
	{
		std::unordered_map<std::string, uint64_t> dict;
		dict["xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"] = 1;
		dict["yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy"] = 2;
		dict["zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz"] = 3;
	}
	std::cout << "CPP1 elapsed = " << sw() << std::endl;
	for (int i = 0; i < 99999; ++i)
	{
		auto dict = mpb.CreateWithoutTypeId<xx::Dict<xx::String*, uint64_t, true>>();
		dict->KeyAt(dict->Add(mpb.CreateWithoutTypeId<xx::String>("xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"), 1).index)->Release();
		dict->KeyAt(dict->Add(mpb.CreateWithoutTypeId<xx::String>("yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy"), 2).index)->Release();
		dict->KeyAt(dict->Add(mpb.CreateWithoutTypeId<xx::String>("zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz"), 3).index)->Release();
		dict->Release();
	}
	std::cout << "CPP2 elapsed = " << sw() << std::endl;
	lua_close(L1);
	lua_close(L2);

	return 0;
}







template<typename T>
struct SPtr
{
	T* ptr;
	SPtr(T* ptr) : ptr(ptr) {}
	SPtr(SPtr const& o)
	{
		if(o.ptr) o.ptr->AddRef();
		ptr = o.ptr;
	}
	SPtr(SPtr && o)
	{
		ptr = o.ptr;
		o.ptr = nullptr;
	}
	SPtr& operator=(SPtr const& o)
	{
		if (o.ptr) o.ptr->AddRef();
		if (ptr) ptr->Release();
		ptr = o.ptr;
	}
	SPtr& operator=(SPtr && o)
	{
		std::swap(ptr, o.ptr);
	}
	~SPtr()
	{
		if (ptr) ptr->Release();
	}
};