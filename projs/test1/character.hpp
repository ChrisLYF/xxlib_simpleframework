Character::Character()
	: quests(scene())
{
	// 加载上次玩家下线时的任务列表以及任务上下文数据
}

Character::~Character()
{
	// 针对未完成的 quest, 做持久化存储
	// 也就是说, 任务脚本在执行过程中, 可以通过某种方式来存储一些上下文, 以供下次启动后恢复状态
	// 一种考虑是, lua 里有一张表, 当前任务随便读写. 杀角色时, 无脑序列化保存这张表( 初期限制成员数据类型为  表, 数字, 字串 )
	// 另一种考虑是 c++ 做类似的一个存储体, 映射到 lua, 当前任务脚本可以方便的读写, 和上面操作表的方式和限制类似

	// 考虑任务完成时的掉落处理. 掉落表的配置方式? 结构设计?

	/*

todo: 玩家身上的 任务状态标志 存储区的长相
todo2: 玩家身上的 为任务/成就服务的 各式统计数据长相
todo3: 任务剧情/对话功能融入思考( 主客户端 )
todo4: 任务编辑器, 单元测试系统
todo5: 物品事件与脚本( 拾取 / 使用 / 摧毁 啥的 )( 能影响任务或玩家状态之类 )
todo6: 游戏内的任务管理器, 奖励领取管理?

任务系统设计
任务状态标志:	未接, 已接(进行中), 已完成( 没领取奖励 ), 已交( 奖励已发放 ), 已失败( 有时等同于未接 )

任务项基本数据结构: ( 分类 / 显示 / NPC绑定啥的 在子表 )
id, pid, groupId, 接脚本, 执行脚本, 交脚本, 放弃脚本, 掉落脚本, 查询脚本, 附加存储 .....

id:			任务配置编号
pid:		父任务编号( 因为太长用, 故抽取出来以减轻条件脚本判断负担 ). 可以被条件脚本访问.
groupid:	任务分组编号, 主用于 n 选 1 支线互斥任务判断, 也用于任务本身去重. 可以被条件脚本访问.
接脚本:		任务分配器筛选执行, 可访问目标玩家数据, 通常内含统计/任务标志信息, 返回是否有资格接这个任务
执行脚本:   场景服动态加载, 附到具体目标类上, 于 Update 时以协程方式执行, 执行完毕时修改任务标志
交脚本:		提供任务奖励的具体执行功能, 以及相关任务物品的移除功能, 状态标志修改功能( 改成已交 )
放弃脚本:	提供相关任务物品的移除功能, 状态标志清除功能( 删任务 )
掉落脚本:	提供任务相关附加掉落表的填充( 只要任务状态为 正在做 便一直生效 )
查询脚本:	通过访问玩家数据及附加存储, 提供用于展示任务进展 / 具体情况的数据流( 主要是客户端用 )
附加存储:	可理解为一个 int, number 字典, 主用于 lua 存储任务恢复执行所需关键性数据( 理论上讲也可以发给 client 以取代查询脚本 )

掉落表及算法
基本结构:
掉什么, 数量范围, 权值

计算时采用先将权值累加到一起, 再按该值范围随机, 最后逐个拿权值去减( 减到 <= 0 的时候即命中 )
掉落表来源: 最基本的部分为配置文件, 附加/修订部分通常为任务系统 "掉落脚本" 结合玩家当前的数据来计算并填充

	*/
}
