Character::Character()
	: quests(scene())
{
	// 加载上次玩家下线时的任务列表以及任务上下文数据
}

Character::~Character()
{
	// 针对未完成的 quest, 做持久化存储
	// 也就是说, 任务脚本在执行过程中, 可以通过某种方式来存储一些上下文, 以供下次启动后恢复状态
	// 一种考虑是, lua 里有一张表, 当前任务随便读写. 杀角色时, 无脑序列化保存这张表( 初期限制成员数据类型为  表, 数字, 字串 )
	// 另一种考虑是 c++ 做类似的一个存储体, 映射到 lua, 当前任务脚本可以方便的读写, 和上面操作表的方式和限制类似

	// 考虑任务完成时的掉落处理. 掉落表的配置方式? 结构设计?

	/*

todo: 玩家身上的 任务状态标志 存储区的长相
todo2: 玩家身上的 为任务/成就服务的 各式统计数据长相
todo3: 任务剧情/对话功能融入思考( 主客户端 )
todo4: 任务编辑器, 单元测试系统
todo5: 物品事件与脚本( 拾取 / 使用 / 摧毁 啥的 )( 能影响任务或玩家状态之类 )
todo6: 游戏内的任务管理器, 奖励领取管理?

任务系统设计
任务状态标志:	未接, 已接(进行中), 已完成( 没领取奖励 ), 已交( 奖励已发放 ), 已失败( 有时等同于未接 )

任务项基本数据结构: ( 分类 / 显示 / NPC绑定啥的 在子表 )
id, pid, groupId, 接脚本, 执行脚本, 交脚本, 放弃脚本, 掉落脚本, 查询脚本, 附加存储 .....

id:			任务配置编号
pid:		父任务编号( 因为太长用, 故抽取出来以减轻条件脚本判断负担 ). 可以被条件脚本访问.
groupid:	任务分组编号, 主用于 n 选 1 支线互斥任务判断, 也用于任务本身去重. 可以被条件脚本访问.
接脚本:		任务分配器筛选执行, 可访问目标玩家数据, 通常内含统计/任务标志信息, 返回是否有资格接这个任务
执行脚本:   场景服动态加载, 附到具体目标类上, 于 Update 时以协程方式执行, 执行完毕时修改任务标志
交脚本:		提供任务奖励的具体执行功能, 以及相关任务物品的移除功能, 状态标志修改功能( 改成已交 )
放弃脚本:	提供相关任务物品的移除功能, 状态标志清除功能( 删任务 )
掉落脚本:	提供任务相关附加掉落表的填充( 只要任务状态为 正在做 便一直生效 )
查询脚本:	通过访问玩家数据及附加存储, 提供用于展示任务进展 / 具体情况的数据流( 主要是客户端用 )
附加存储:	可理解为一个 LUA 表 / int, number 字典, 主用于 lua 存储任务恢复执行所需关键性数据( 理论上讲也可以发给 client 以取代查询脚本 )

注意事项:	考虑到玩家可能因上下线 / 进出地图 / 副本而随时终止脚本的执行, 脚本在书写过程中, 必须随时持久化保存状态


掉落表及算法
基本结构:
掉什么, 数量范围, 权值

计算时采用先将权值累加到一起, 再按该值范围随机, 最后逐个拿权值去减( 减到 <= 0 的时候即命中 )
掉落表来源: 最基本的部分为配置文件, 附加/修订部分通常为任务系统 "掉落脚本" 结合玩家当前的数据来计算并填充





关于 skynet 接入的注意事项

接口需求: 代码以 c 函数的方式提供运行实现, 得拆成  初始化函数( 返回场景指针 ), 析构函数( 杀场景指针 ), 塞消息函数( 模拟收到玩家数据 ), 更新函数( 处理并返回结果 )

大原则( 初步确定 ): 对于需要持久化的数据, 需要先向 skynet agent 发起异步请求, 等待处理结果到达, 再进行处理.

已知的问题: 异步请求的时间有可能会比较长( 比如已经过了一两帧啥的 )

问题1: 玩家喝药, 数据包会先经过 agent 再流向战斗服, 结合上面的已知问题, 会导致喝药及后续数据包滞留在 agent 处, 等异步校验通过后, 再流向战斗服, 恐有额外延迟问题产生. 这问题如何解决?  

问题2: 如果服务器端受伤自动喝药, 会导致失血需要喝的当前帧只能向 agent 发起喝药请求, 至少要到下一帧经确认后, 才能真喝( 这时玩家已死, 喝药失败 ), 故发起的内容还不能是直接喝, 而是请求保留1瓶药, 收到保留成功之后, 再喝, 同时再发一条 已喝 到 agent 以确认该操作. 但如果第 2 帧没有收到 agent 的反馈, 血量又有变化, 理论上讲该喝第 2 瓶药了, 那此时是否应该向 agent 再次发起保留1瓶药的请求? 

问题3: 到底会延迟多久? 如果制作人或策划不接受怎么办? 如果延迟无法解决, 那是否可以控制到延迟最多为 1 帧? 如果无法控制, 策划如何告知玩家这个事?


	*/
}

/*




Wearhouse = []

Inv = 
[
	{ cfgId = 1(下标), count = ??, detail = [ cellIdx,....  ] },
	{ cfgId = 2(下标), count = ??, detail = [ cellIdx,.... ] },
	{ cfgId = 3(下标), count = ??, detail = [ cellIdx,.... ] },
	{ cfgId = 4(定制), attach_properties = {............}, count = ??, detail = [ { cellIdx = ???, amount = ??? }, ....  ] },
	...
]

Cells =
[{ cellIdx = ???(下标), cfgId = ??, amount = ??? }......  ]



背包数据结构设计:

List<Item*> cells; // cellIdx 下标, 主体存储容器
List<pair<Item*, int>> items; // cfgId 下标, pair Item*: 相同cfgId的 item 链表头. int 为总数

struct Item
{
	int cfgId;
	int cellIdx;
	Item* next;
	Item* prev;
	int amount;
	...
}

加载时, 每一格物品, 都按 cfgId new 成一个独立 Item 类, 塞 cells. 塞的过程中, 填充 items 汇总容器.
持久化时, 扫 cells 依次序列化 Item. 忽略 next prev.


*/
